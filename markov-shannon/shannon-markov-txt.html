<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compresor Shannon-Markov</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0 20px; background-color: #f4f7f6; color: #333; }
        .container { max-width: 800px; margin: 20px auto; padding: 20px; background-color: #fff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
        h1, h2, h3 { color: #1a535c; }
        h1 { text-align: center; }
        h3 { border-bottom: 2px solid #4ecdc4; padding-bottom: 5px; }
        textarea { width: 98%; min-height: 100px; border: 1px solid #ccc; border-radius: 4px; padding: 10px; font-family: monospace; font-size: 14px; margin-top: 10px; }
        button, input[type="file"] { background-color: #4ecdc4; color: white; border: none; padding: 12px 18px; border-radius: 4px; cursor: pointer; font-size: 16px; margin-top: 10px; transition: background-color 0.2s; }
        button:hover { background-color: #1a535c; }
        
        /* Estilo para el input de DESCOMPRIMIR (.mkvshn) */
        #fileInput { background-color: #f9a03f; }
        #fileInput:hover { background-color: #d97d1b; }

        /* NUEVO Estilo para el input de CARGAR TEXTO (.txt) */
        #textFileInput { background-color: #5c8f94; }
        #textFileInput:hover { background-color: #4a7275; }

        pre { background-color: #282c34; color: #abb2bf; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; }
        .error { color: #ff6b6b; font-weight: bold; }
        .success { color: #4ecdc4; font-weight: bold; }
    </style>
</head>
<body>

    <div class="container">
        <h1>Compresor Shannon-Markov (Grado 1)</h1>

        <h3>Paso 1: Comprimir y Descargar</h3>
        <p>Escribe el texto o carga un archivo <code>.txt</code>. Luego presiona "Comprimir".</p>
        
        <input type="file" id="textFileInput" accept=".txt">
        
        <textarea id="textInput" rows="5" placeholder="Escribe aquí o carga un archivo .txt..."></textarea>
        <button id="btnDescargar">Comprimir y Descargar Archivo (.mkvshn)</button>
        <h3>Paso 2: Cargar y Descomprimir</h3>
        <p>Adjunta el archivo <code>.mkvshn</code> que acabas de descargar. Se usará el modelo en memoria para decodificarlo.</p>
        <input type="file" id="fileInput" accept=".mkvshn">

        <h3>Resultados (Log)</h3>
        <pre id="logOutput">Esperando acciones...</pre>
    </div>

    <script>
        // --- INICIO: Lógica de la Interfaz (UI) ---

        // Variable global para guardar el modelo. Es la "llave"
        let markovShannonModel = null;
        let originalTextForComparison = "";

        const textInput = document.getElementById("textInput");
        const btnDescargar = document.getElementById("btnDescargar");
        const fileInput = document.getElementById("fileInput"); // Para .mkvshn
        const textFileInput = document.getElementById("textFileInput"); // NUEVO: Para .txt
        const logOutput = document.getElementById("logOutput");

        // Helper para mostrar mensajes en el <pre> y en la consola
        function log(message, type = "") {
            console.log(message);
            if (typeof message === 'object') {
                message = JSON.stringify(message, null, 2);
            }
            const line = document.createElement("div");
            line.textContent = message;
            if (type === "error") line.classList.add("error");
            if (type === "success") line.classList.add("success");
            logOutput.appendChild(line);
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        function clearLog() {
            logOutput.innerHTML = "";
        }

        // --- INICIO: NUEVA LÓGICA ---
        // --- Evento: Carga de un archivo .txt ---
        textFileInput.addEventListener("change", async (event) => {
            clearLog();
            const file = event.target.files[0];
            if (!file) {
                log("No se seleccionó ningún archivo de texto.", "error");
                return;
            }

            log(`Cargando archivo "${file.name}"...`);

            try {
                // Leemos el archivo como TEXTO
                const fileContent = await file.text();
                
                // Ponemos el contenido en el textarea
                textInput.value = fileContent;
                log(`Archivo "${file.name}" cargado en el área de texto.`, "success");
                log("¡Listo para presionar 'Comprimir y Descargar'!");
                
            } catch (e) {
                log(`Error al leer el archivo de texto: ${e.message}`, "error");
                console.error(e);
            } finally {
                // Resetea el input para poder cargar el mismo archivo de nuevo
                event.target.value = null;
            }
        });
        // --- FIN: NUEVA LÓGICA ---


        // --- Evento: Clic en el botón de descargar ---
        btnDescargar.addEventListener("click", () => {
            clearLog();
            const str = textInput.value;
            if (!str) {
                log("Error: El texto de entrada está vacío.", "error");
                return;
            }

            try {
                // 1. Crear el modelo (la "llave")
                log("Creando modelo Markov (Grado 1)...");
                markovShannonModel = new Markov(str, 1);
                originalTextForComparison = str; // Guardamos el texto original
                log("Modelo creado con éxito.");

                // 2. Codificar el texto
                log("Codificando texto...");
                const encodedShannon = markovShannonModel.encode(str);
                log(`Cadena de bits: ${encodedShannon.slice(0, 100)}...`);

                // 3. Empaquetar los bits para guardar
                const bitLength = encodedShannon.length;
                const packedArray = packBits(encodedShannon);
                log(`Longitud original de bits: ${bitLength}`);
                log(`Tamaño empaquetado (bytes): ${packedArray.byteLength}`);

                // 4. Crear el encabezado (4 bytes para la longitud)
                const header = new Uint32Array([bitLength]);

                // 5. Crear el Blob (archivo) combinando el encabezado y los datos
                const fileBlob = new Blob([header, packedArray], {
                    type: "application/octet-stream",
                });

                // 6. Disparar la descarga
                downloadBlob(fileBlob, "comprimido.mkvshn");
                log("\nArchivo .mkvshn generado.", "success");
                log("¡Listo para el Paso 2! Sube el archivo que acabas de descargar.");

            } catch (e) {
                log(`Error durante la compresión: ${e.message}`, "error");
                console.error(e);
            }
        });

        // --- Evento: Carga de un archivo .mkvshn ---
        fileInput.addEventListener("change", async (event) => {
            clearLog();
            const file = event.target.files[0];

            // 0. Validar que el modelo (la "llave") exista
            if (!markovShannonModel) {
                log("Error: Primero debes comprimir un texto (Paso 1).", "error");
                log("El modelo (la 'llave') debe estar en memoria para poder decodificar.");
                return;
            }

            if (!file) {
                log("No se seleccionó ningún archivo.", "error");
                return;
            }

            log(`--- Leyendo archivo "${file.name}" ---`);

            try {
                // 1. Leer el archivo como un ArrayBuffer binario
                const fileBuffer = await file.arrayBuffer();

                // 2. Separar el encabezado y los datos
                const headerView = new Uint32Array(fileBuffer, 0, 1);
                const bitLength = headerView[0];
                const packedArray = new Uint8Array(fileBuffer, 4);

                log(`Lectura: bitLength (del header): ${bitLength}`);
                log(`Lectura: bytes de datos (del body): ${packedArray.byteLength}`);

                // 3. Desempaquetar los datos de vuelta a la cadena de bits
                const encodedFromFile = unpackBits(packedArray, bitLength);
                log(`Cadena de bits (leída): ${encodedFromFile.slice(0, 100)}...`);

                // 4. Decodificar usando el modelo en memoria
                log("Decodificando...");
                const decodedString = markovShannonModel.decode(encodedFromFile);

                // 5. Mostrar resultados
                log("\n--- RESULTADO ---", "success");
                log(`Original (guardado): ${originalTextForComparison.slice(0, 200)}...`);
                log(`Decodificado (del archivo): ${decodedString.slice(0, 200)}...`);
                const
                    coinciden = originalTextForComparison === decodedString;
                log(`¿Coinciden?: ${coinciden}`, coinciden ? "success" : "error");

                // 6. Guardar el archivo decodificado para comparar
                if (coinciden) {
                    log("Generando archivo decodificado (descomprimido.txt)...");
                    const decodedBlob = new Blob([decodedString], {
                        type: "text/plain;charset=utf-8", // Guardar como texto plano UTF-8
                    });
                    downloadBlob(decodedBlob, "descomprimido.txt");
                    log("Archivo descomprimido.txt generado.", "success");
                } else {
                    log("No se generó el archivo decodificado porque la decodificación falló.", "error");
                }

            } catch (e) {
                log(`Error durante la descompresión: ${e.message}`, "error");
                console.error(e);
            } finally {
                // Resetea el input de archivo para poder cargar el mismo de nuevo
                event.target.value = null;
            }
        });


        // --- FIN: Lógica de la Interfaz (UI) ---


        // --- INICIO: Funciones Auxiliares (Binarias) ---

        /**
         * Empaqueta una cadena de bits (ej: "1011001") en un arreglo de bytes.
         */
        function packBits(bitString) {
            const bitLength = bitString.length;
            const byteLength = Math.ceil(bitLength / 8);
            const byteArray = new Uint8Array(byteLength);

            for (let i = 0; i < byteLength; i++) {
                const byteSlice = bitString.slice(i * 8, (i + 1) * 8);
                const byteString = byteSlice.padEnd(8, "0");
                byteArray[i] = parseInt(byteString, 2);
            }
            return byteArray;
        }

        /**
         * Desempaqueta un Uint8Array (bytes) de vuelta a una cadena de bits.
         */
        function unpackBits(buffer, bitLength) {
            let bitString = "";
            for (let i = 0; i < buffer.length; i++) {
                bitString += buffer[i].toString(2).padStart(8, "0");
            }
            return bitString.slice(0, bitLength); // Recorta al tamaño original
        }

        /**
         * Dispara la descarga de un Blob en el navegador.
         */
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- FIN: Funciones Auxiliares (Binarias) ---


        // --- INICIO: TU CÓDIGO (Transpilado a JS) ---

        const sum = (arr) => arr.reduce((a, b) => a + b, 0);

        class Shannon {
            constructor(probabilities, base = 2) {
                if (Math.abs(sum(Object.values(probabilities)) - 1) > 0.01) {
                    throw new Error("Las probabilidades deben sumar 1");
                }
                this.probabilities = probabilities;
                this.base = base;
                this.codes = {};

                this._makeCodes();
                const codesList = Object.values(this.codes);
                const symbols = this.symbols; // Usar el getter

                for (const symbol of symbols) {
                    if (!this.codes[symbol]) {
                        throw new Error("Todos los símbolos deben tener un código");
                    }

                    const code = this.codes[symbol];
                    if (codesList.some((c) => code.startsWith(c) && code !== c)) {
                        throw new Error("Los códigos deben ser libres de prefijos");
                    }
                }
            }

            get symbols() {
                return Object.keys(this.probabilities);
            }

            encodeOne(str) {
                const symbol = this.symbols.find((symbol) => str.startsWith(symbol));
                if (!symbol) throw new Error("Símbolo inválido en encodeOne: " + str);
                return [symbol, this.codes[symbol]];
            }

            encode(str) {
                let encoded = "";
                while (str.length) {
                    const [symbol, code] = this.encodeOne(str);
                    encoded += code;
                    str = str.slice(symbol.length);
                }
                return encoded;
            }

            decodeOne(str) {
                const symbol = this.symbols.find((symbol) =>
                    str.startsWith(this.codes[symbol])
                );
                if (!symbol) throw new Error("Símbolo inválido en decodeOne: " + str);
                return [symbol, this.codes[symbol]];
            }

            decode(str) {
                let decoded = "";
                while (str.length) {
                    const [symbol, code] = this.decodeOne(str);
                    decoded += symbol;
                    str = str.slice(code.length);
                }
                return decoded;
            }

            _makeCode(length, symbol) {
                let num = 0;
                while (num < this.base ** length) {
                    const code = num.toString(this.base).padStart(length, "0");
                    const conflict = Object.values(this.codes).some(
                        (c) => code.startsWith(c) || c.startsWith(code)
                    );
                    if (!conflict) {
                        return code;
                    }
                    num++;
                }
                throw new Error("No se encontró código (esto no debería pasar)");
            }

            _makeCodes() {
                for (const symbol of this.symbols) {
                    const length = Math.ceil(
                        -Math.log2(this.probabilities[symbol])
                    );
                    this.codes[symbol] = this._makeCode(length, symbol);
                }
            }
        }

        const subdivideString = (str, order) => {
            const substrings = [];
            for (let i = 0; i < str.length - order + 1; i++) {
                substrings.push(str.slice(i, i + order));
            }
            return substrings;
        };

        class Markov {
            constructor(str, order = 1) {
                this.symbols = Array.from(new Set(str.split(""))).sort();
                this.order = order;

                const l = Math.ceil(Math.log2(this.symbols.length));
                this.pseudoASCIILength = l;
                this.pseudoASCII = {};
                for (let i = 0; i < this.symbols.length; i++) {
                    this.pseudoASCII[this.symbols[i]] = i.toString(2).padStart(l, "0");
                }

                this.codifications = {}; // Inicializar
                this._makeCodes(str);
            }

            _makeCodes(str) {
                const divisions = subdivideString(str, this.order + 1);
                const keys = [...new Set(divisions.map((str) => str.slice(0, -1)))];

                for (const key of keys) {
                    const uses = divisions.filter((str) => str.startsWith(key));
                    const probabilities = {};

                    for (const use of uses) {
                        const symbol = use.slice(-1);
                        probabilities[symbol] = (probabilities[symbol] || 0) + 1;
                    }

                    for (const symbol in probabilities) {
                        probabilities[symbol] = probabilities[symbol] / uses.length;
                    }
                    // Descomentar para logs detallados de probabilidades:
                    // log(`\n📈 Contexto "${key}" -> Probabilidades: ${JSON.stringify(probabilities)}`);
                    this.codifications[key] = new Shannon(probabilities);
                    // log(`📊 Códigos para contexto "${key}": ${JSON.stringify(this.codifications[key].codes)}`);
                }
            }

            encodeASCII(str) {
                return this.symbols
                    .findIndex((x) => x === str[0])
                    .toString(2)
                    .padStart(this.pseudoASCIILength, "0");
            }

            encode(str) {
                let encoded = "";
                for (let i = 0; i < this.order; i++) {
                    encoded += this.encodeASCII(str[i]);
                }

                let prev = str.slice(0, this.order);
                for (let i = this.order; i < str.length; i++) {
                    if (!this.codifications[prev]) {
                         throw new Error(`Error de codificación: No existe contexto para "${prev}"`);
                    }
                    encoded += this.codifications[prev].encode(str[i]);
                    prev = prev.slice(1) + str[i];
                }

                return encoded;
            }

            decodeASCII(str) {
                const code = str.slice(0, this.pseudoASCIILength);
                const symbol = this.symbols[parseInt(code, 2)];
                return [symbol, code];
            }

            decode(str) {
                let decoded = "";

                while (str.length) {
                    const [symbol, code] =
                        decoded.length < this.order ?
                        this.decodeASCII(str) :
                        this.codifications[decoded.slice(-this.order)].decodeOne(str);

                    if (!symbol) {
                        throw new Error(`Decodificación fallida: no se encontró símbolo para el contexto "${decoded.slice(-this.order)}" y la cadena "${str.slice(0, 10)}..."`);
                    }

                    decoded += symbol;
                    str = str.slice(code.length);
                }

                return decoded;
            }
        }

        // --- FIN: TU CÓDIGO ---

    </script>
</body>
</html>