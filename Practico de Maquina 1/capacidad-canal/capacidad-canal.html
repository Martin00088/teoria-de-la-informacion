<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Calculadora de Capacidad de Canal (R-aria)</title>
    <style>
      :root {
        font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto,
          "Helvetica Neue", Arial;
      }
      body {
        background: #0f172a;
        color: #e6eef8;
        margin: 0;
        padding: 24px;
      }
      .container {
        max-width: 980px;
        margin: 0 auto;
        background: linear-gradient(180deg, #071233 0%, #08142b 100%);
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 8px 30px rgba(2, 6, 23, 0.6);
      }
      h1 {
        font-size: 20px;
        margin: 0 0 12px;
      }
      p.small {
        color: #9fb0d6;
        margin: 6px 0 18px;
      }
      .row {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }
      label {
        font-size: 13px;
        color: #bcd3f0;
      }
      select,
      input[type="number"] {
        padding: 8px;
        border-radius: 8px;
        border: 1px solid #16324a;
        background: #071a2a;
        color: #dff;
        outline: none;
      }
      button {
        background: #22c55e;
        border: none;
        color: #042017;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }
      button.secondary {
        background: #3b82f6;
        color: white;
      }
      .matrix {
        display: inline-grid;
        gap: 6px;
        margin-top: 8px;
      }
      .cell {
        width: 84px;
      }
      table {
        border-collapse: collapse;
        margin-top: 12px;
      }
      td,
      th {
        padding: 6px 8px;
        border: 1px solid rgba(255, 255, 255, 0.06);
        font-family: monospace;
      }
      .output {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.01)
        );
        padding: 12px;
        border-radius: 10px;
        margin-top: 12px;
      }
      .code {
        background: rgba(255, 255, 255, 0.02);
        padding: 8px;
        border-radius: 6px;
        font-family: monospace;
      }
      .note {
        font-size: 13px;
        color: #a8c1e8;
        margin-top: 8px;
      }
      .smallbtn {
        padding: 6px 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: transparent;
        color: #dff;
      }
      footer {
        margin-top: 18px;
        font-size: 12px;
        color: #7fa0d9;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Calculadora de Capacidad de Canal (R-aria)</h1>
      <p class="small">
        Elija R (número de símbolos de entrada). Ingrese la matriz de
        probabilidades condicionales P(y|x) (cada fila corresponde a una entrada
        x y debe sumar 1). Luego haga clic en
        <strong>Calcular Capacidad</strong> para obtener la distribución de
        entrada óptima p(x) que maximiza I(X;Y) y el valor de la capacidad en
        bits.
      </p>

      <div class="row">
        <label for="rsel">R (alfabeto de entrada):</label>
        <select id="rsel">
          <option value="2">2 (Binario)</option>
          <option value="3">3 (Ternario)</option>
          <option value="4">4 (Quaternario)</option>
        </select>

        <label for="ycount">M (alfabeto de salida):</label>
        <select id="ycount">
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
        </select>

        <button id="gen" class="secondary">Generar matriz</button>

        <label style="margin-left: 8px"
          ><input type="checkbox" id="fillUniform" /> Usar P(y|x)
          uniforme</label
        >
      </div>

      <div id="matrixArea"></div>

      <div class="row">
        <label for="maxIter">Iteraciones máximas:</label>
        <input
          id="maxIter"
          type="number"
          min="1"
          value="2000"
          style="width: 110px"
        />
        <label for="tol">Tolerancia (eps):</label>
        <input
          id="tol"
          type="number"
          step="1e-8"
          value="1e-9"
          style="width: 140px"
        />
        <button id="run">Calcular Capacidad</button>
        <button id="uniformIn">Evaluar con p(x) uniforme</button>
      </div>

      <div class="output" id="output">
        <div id="resultHeader" style="font-weight: 700">Resultados</div>
        <div id="resultBody" style="margin-top: 8px">
          Aún no se ha calculado.
        </div>
      </div>

      <div class="note">
        Algoritmo: <strong>Blahut–Arimoto</strong> (iterativo, numérico). Maneja
        P(y|x)=0 correctamente. Las entradas de la matriz deben ser
        probabilidades (filas que sumen aproximadamente 1).
      </div>

      <footer>
        Puedes copiar el HTML y abrirlo localmente en tu navegador.
      </footer>
    </div>

    <script>
      // Utilidades
      function createMatrixInputs(R, M, uniformFill) {
        const container = document.createElement("div");
        container.className = "matrixBlock";
        const title = document.createElement("div");
        title.innerHTML = `<strong>Matriz P(y|x) — filas: x (0..${
          R - 1
        }), columnas: y (0..${M - 1})</strong>`;
        container.appendChild(title);
        const grid = document.createElement("div");
        grid.className = "matrix";
        grid.style.gridTemplateColumns = `repeat(${M}, 1fr)`;

        // header
        const headerRow = document.createElement("table");
        const hdr = headerRow.insertRow();
        hdr.insertCell().textContent = "";
        for (let j = 0; j < M; j++) {
          const c = hdr.insertCell();
          c.textContent = "y=" + j;
        }

        const tbl = document.createElement("table");
        // build rows
        for (let i = 0; i < R; i++) {
          const row = tbl.insertRow();
          row.insertCell().textContent = "x=" + i;
          for (let j = 0; j < M; j++) {
            const cell = row.insertCell();
            const inp = document.createElement("input");
            inp.type = "number";
            inp.step = "any";
            inp.min = 0;
            inp.className = "cell";
            inp.dataset.x = i;
            inp.dataset.y = j;
            inp.value = uniformFill
              ? 1 / M
              : j === 0
              ? 0.9
              : (1 - 0.9) / (M - 1);
            cell.appendChild(inp);
          }
        }
        container.appendChild(tbl);

        // helper row-sum show
        const sumsDiv = document.createElement("div");
        sumsDiv.className = "note";
        sumsDiv.style.marginTop = "6px";
        sumsDiv.id = "rowSums";
        container.appendChild(sumsDiv);

        // button normalize rows
        const normBtn = document.createElement("button");
        normBtn.className = "smallbtn";
        normBtn.textContent = "Normalizar filas (sum=1)";
        normBtn.onclick = () => {
          normalizeRows(tbl);
          updateRowSums(tbl);
        };
        container.appendChild(normBtn);

        // attach listeners
        tbl
          .querySelectorAll("input")
          .forEach((inp) =>
            inp.addEventListener("input", () => updateRowSums(tbl))
          );
        updateRowSums(tbl);

        return container;
      }

      function updateRowSums(tbl) {
        const rows = tbl.rows;
        let text = "";
        for (let i = 0; i < rows.length; i++) {
          let s = 0;
          for (let j = 1; j < rows[i].cells.length; j++) {
            const v =
              parseFloat(rows[i].cells[j].querySelector("input").value) || 0;
            s += v;
          }
          text += `fila x=${i} suma = ${s.toFixed(10)}  `;
        }
        const sumsDiv = document.getElementById("rowSums");
        if (sumsDiv) sumsDiv.textContent = text;
      }

      function normalizeRows(tbl) {
        const rows = tbl.rows;
        for (let i = 0; i < rows.length; i++) {
          let s = 0;
          for (let j = 1; j < rows[i].cells.length; j++) {
            const v =
              parseFloat(rows[i].cells[j].querySelector("input").value) || 0;
            s += v;
          }
          if (s <= 0) continue;
          for (let j = 1; j < rows[i].cells.length; j++) {
            const inp = rows[i].cells[j].querySelector("input");
            inp.value = (parseFloat(inp.value || 0) / s).toPrecision(10);
          }
        }
      }

      function readMatrix(tbl) {
        const rows = tbl.rows;
        const R = rows.length;
        const M = rows[0].cells.length - 1;
        const P = new Array(R);
        for (let i = 0; i < R; i++) {
          P[i] = new Array(M);
          let s = 0;
          for (let j = 0; j < M; j++) {
            const v =
              parseFloat(rows[i].cells[j + 1].querySelector("input").value) ||
              0;
            P[i][j] = v;
            s += v;
          }
          // do NOT force normalize here; we will allow slight deviations but warn
        }
        return P;
      }

      function approxEqual(a, b, eps = 1e-9) {
        return Math.abs(a - b) <= eps;
      }

      // Blahut-Arimoto implementation
      function blahutArimoto(P, options = { maxIter: 2000, tol: 1e-9 }) {
        // P: R x M matrix P[y|x] as P[x][y]
        const R = P.length;
        const M = P[0].length;
        let p = new Array(R).fill(1 / R); // initial input distribution
        let q = new Array(M).fill(0);
        let prevI = -Infinity;
        let I = 0;
        const history = [];
        for (let iter = 0; iter < options.maxIter; iter++) {
          // q(y) = sum_x p(x) P(y|x)
          for (let y = 0; y < M; y++) {
            q[y] = 0;
          }
          for (let x = 0; x < R; x++)
            for (let y = 0; y < M; y++) q[y] += p[x] * P[x][y];

          // compute t(x) = exp( sum_y P[y|x] * log( P[y|x] / q(y) ) )
          const t = new Array(R);
          for (let x = 0; x < R; x++) {
            let s = 0;
            for (let y = 0; y < M; y++) {
              const Pyx = P[x][y];
              if (Pyx <= 0) continue; // term zero
              const ratio = Pyx / (q[y] > 0 ? q[y] : 1e-300);
              s += Pyx * Math.log(ratio); // natural log
            }
            t[x] = Math.exp(s);
          }
          // normalize
          const tSum = t.reduce((a, b) => a + b, 0);
          if (tSum === 0) break;
          const pnew = t.map((v) => v / tSum);

          // compute mutual info I = sum_{x,y} pnew[x]*P[x][y]*log2(P[x][y]/q[y])
          let Ibits = 0;
          for (let x = 0; x < R; x++)
            for (let y = 0; y < M; y++) {
              const Pyx = P[x][y];
              if (Pyx <= 0) continue;
              const qy = q[y] > 0 ? q[y] : 1e-300;
              Ibits += pnew[x] * Pyx * (Math.log(Pyx / qy) / Math.LN2);
            }
          history.push({ iter, I: Ibits, p: pnew.slice() });

          if (Math.abs(Ibits - prevI) < options.tol) {
            p = pnew;
            I = Ibits;
            break;
          }
          prevI = Ibits;
          p = pnew;
          I = Ibits;
        }
        return { capacity: I, p, history };
      }

      function evaluateMutualInfo(P, p) {
        const R = P.length;
        const M = P[0].length;
        const q = new Array(M).fill(0);
        for (let x = 0; x < R; x++)
          for (let y = 0; y < M; y++) q[y] += p[x] * P[x][y];
        let Ibits = 0;
        for (let x = 0; x < R; x++)
          for (let y = 0; y < M; y++) {
            const Pyx = P[x][y];
            if (Pyx <= 0) continue;
            const qy = q[y] > 0 ? q[y] : 1e-300;
            Ibits += p[x] * Pyx * (Math.log(Pyx / qy) / Math.LN2);
          }
        return { Ibits, q };
      }

      // UI wiring
      const rsel = document.getElementById("rsel");
      const genBtn = document.getElementById("gen");
      const matrixArea = document.getElementById("matrixArea");
      const runBtn = document.getElementById("run");
      const outBody = document.getElementById("resultBody");
      const fillUniform = document.getElementById("fillUniform");
      const ycount = document.getElementById("ycount");
      const uniformInBtn = document.getElementById("uniformIn");

      genBtn.onclick = () => {
        const R = parseInt(rsel.value, 10);
        const M = parseInt(ycount.value, 10);
        matrixArea.innerHTML = "";
        const block = createMatrixInputs(R, M, fillUniform.checked);
        matrixArea.appendChild(block);
      };

      // generate initial
      genBtn.click();

      runBtn.onclick = () => {
        const maxIter =
          parseInt(document.getElementById("maxIter").value, 10) || 2000;
        const tol = parseFloat(document.getElementById("tol").value) || 1e-9;
        const tbl = matrixArea.querySelector("table");
        if (!tbl) {
          alert("Genere primero la matriz.");
          return;
        }
        const P = readMatrix(tbl);
        // basic validation rows
        const warn = [];
        for (let i = 0; i < P.length; i++) {
          const s = P[i].reduce((a, b) => a + b, 0);
          if (!approxEqual(s, 1, 1e-6))
            warn.push(`fila x=${i} suma=${s.toFixed(8)} (no ≈ 1)`);
        }
        if (warn.length)
          if (
            !confirm(
              "Advertencia:\n" + warn.join("\n") + "\n\n¿Desea continuar?"
            )
          )
            return;

        outBody.innerHTML = "Calculando...";
        setTimeout(() => {
          // let UI update
          const res = blahutArimoto(P, { maxIter, tol });
          const formattedP = res.p.map((v) => Number(v.toFixed(10)));
          let html = `<div><strong>Capacidad (bits):</strong> ${res.capacity.toFixed(
            12
          )}</div>`;
          html += `<div style="margin-top:8px"><strong>Distribución óptima p(x):</strong> <div class="code">[ ${formattedP.join(
            ", "
          )} ]</div></div>`;
          // show detailed table: per x expected divergence
          html += `<div style="margin-top:8px"><strong>Evaluación detallada:</strong></div>`;
          const evalR = evaluateMutualInfo(P, res.p);
          html += `<div class="code">I(X;Y) = ${evalR.Ibits.toFixed(
            12
          )} bits</div>`;
          html += `<div style="margin-top:8px"><strong>q(y) (salida):</strong> <div class="code">[ ${evalR.q
            .map((v) => v.toFixed(10))
            .join(", ")} ]</div></div>`;

          outBody.innerHTML = html;
        }, 50);
      };

      uniformInBtn.onclick = () => {
        const tbl = matrixArea.querySelector("table");
        if (!tbl) {
          alert("Genere la matriz primero.");
          return;
        }
        const P = readMatrix(tbl);
        const R = P.length;
        const p = new Array(R).fill(1 / R);
        const ev = evaluateMutualInfo(P, p);
        outBody.innerHTML = `<div><strong>I con p uniforme:</strong> ${ev.Ibits.toFixed(
          12
        )} bits</div><div style="margin-top:8px"><strong>p uniforme:</strong> <span class="code">[ ${p
          .map((v) => v.toFixed(10))
          .join(
            ", "
          )} ]</span></div><div style="margin-top:8px"><strong>q(y):</strong> <span class="code">[ ${ev.q
          .map((v) => v.toFixed(10))
          .join(", ")} ]</span></div>`;
      };
    </script>
  </body>
</html>
